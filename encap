#!/usr/bin/env python

import time
import os
import encap_lib.encap_settings as settings
from encap_lib.encap_lib import LocalMachine, get_machine, filename_and_file_extension, get_interpreter_from_file_extension, extract_folder_name
from encap_lib.encap_lib import record_process, remove_process_from_database
import yaml
from encap_lib import slurm

def tail_pull(machine, run_folder_name, pid=None):
    if pid is not None:
        machine.run_code(f"tail -f -n +1 --pid={pid} -f {run_folder_name}/log", verbose=True, output=True)
        machine.run_code(f"rm {run_folder_name}/pid")
    else:
        # Runs the tail command until it sees the special character
        machine.run_code(f"""#!/bin/bash
while IFS= read -r LOGLINE || [[ -n "$LOGLINE" ]]; do
    [[ "${{LOGLINE}}" == "{chr(4)}" ]] && exit 0
    printf '%s\\n' "$LOGLINE"
done < <(tail -f {run_folder_name}/log)
""", verbose=True, output=True)
    
    machine.pull(run_folder_name, run_folder_name, directory=True)

# Bash code to run the file and save outputs in log, save PID in the file pid.
def run(machine, interpreter, args, run_folder_name, target_file, target_file_path, interprter_args="", number_of_instances=1):
    machine.push(target_file_path, target_file_path, directory=False, verbose=True)
    

    if isinstance(number_of_instances, int):
        iterator = range(number_of_instances)
    else:
        iterator = number_of_instances

    for i in iterator:

        if i == 0:
            log = "log"
        else:
            log = f"log_{i}"
        
        print_instance = ""
        if len(iterator) > 1:
            print_instance = f"echo 'Instance {i}' &>> {log}"
        
        code = f'''
        set -e # Exit on error
        
        cd {run_folder_name}
        export ENCAP_INSTANCE={i}
        date &> {log}
        echo "host: $(hostname)" &>> {log}
        {print_instance}
        echo "{target_file_path} {args}  \n" &>> {log}
        # Tee avoids buffering
        setsid nohup bash -c "time {interpreter} {interprter_args} {target_file} {args} 2>&1 | tee -a /dev/null" &>> {log} &!
        '''

        if i == 0:
            code += f"""
        PID=$!
        echo $PID 
        echo "$PID" > pid"""
            out = machine.run_code(code, output=True)
            pid = out[0]
            print('PID ' + pid)
        else:
            machine.run_code(code, wait=False)

    return pid

def run_slurm(machine, interpreter, target, args, run_folder_name, target_file_path, slurm_settings, interpreter_args="", name=None):
    machine.push(target_file_path, target_file_path, directory=False, verbose=True)

    # Delete previous log file and create a new one
    machine.run_code(f"""rm {run_folder_name}/pid -f
    rm {run_folder_name}/slurm_files/log* -f
    touch {run_folder_name}/log
    mkdir -p {run_folder_name}/slurm_files
    """)


    # Create the slurm script for all slurm instances
    for i in slurm_settings["i"]:
        if i == 0:
            slurm_instance_text = ""
        else:
            slurm_instance_text = f"_{i}"
        
        runslurm_file_name = f"{run_folder_name}/slurm_files/run{slurm_instance_text}.slurm"
        executable_file_name = f"{run_folder_name}/slurm_files/run{slurm_instance_text}.sh"
        log_file_name = f"{run_folder_name}/slurm_files/log{slurm_instance_text}.slurm"

        # Script to run the file and save outputs in log
        code, args_replace = slurm.generate_slurm_executable(interpreter, run_folder_name, target_file_path, args, slurm_instance=i)

        # Save the script in the run_folder
        machine.write_file(executable_file_name, code, verbose=True)

        # Generate the slurm settings script
        args_ = args_replace.replace(" ", "_")
        if len(args_) != 0 and args_[0] == "_":
            args_ = args_[1:]
        job_name = f"{target}/{name}_{args_}"
        code = slurm.generate_slurm_script(run_folder_name, slurm_settings, runslurm_file_name, executable_file_name, log_file_name, job_name=job_name)

        # Write the slurm file
        machine.write_file(runslurm_file_name, code, verbose=True)

        # Run the slurm file
        machine.run_code(f"sbatch {runslurm_file_name}", verbose=True)

def get_file_name(folder_name):
    i = folder_name[::-1].find("/")
    if i == -1:
        return folder_name
    else:
        i = len(folder_name) - i
        return folder_name[i:]

def mode_run_file(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs, interpreter_args=""):
    assert pargs.name is not None, "The container_name -n must be specified."

    #Syncs folders
    machine.sync_files()

    # Creates folder if it does not exist and checks if the caspsule already exists.
    code = f'''
    mkdir -p {folder_name}
    if [ -d "{run_folder_name}" ]
    then
        echo "exists"
    else
        mkdir -p {run_folder_name}
        echo "ok"
    fi
    '''
    out = machine.run_code(code)
    assert len(out) == 1, str(out)
    out = out[0]

    if out == "ok":
        pass

    elif out == "exists":
        if not pargs.yes:
            c = input(f"The capsule {run_folder_name} already exists. Do you whish to continue y/n? ")
            if c == "y" or c == "Y":
                pass
            else:
                quit()

    else:
        raise Exception(f"Unexpected value {out}.")

    # Copy the local copy of pargs.target to the run_folder
    machine.push(source_file_path, target_file_path, directory=False, verbose=True)

    # Run the file and save outputs in log, save PID in the file pid.
    mode_rerun_file(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs, rerun=False)

def mode_run_folder(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs, interpreter_args=""):
    assert pargs.name is not None, "The container_name -n must be specified."

    #Syncs folders
    machine.sync_files()

    # Creates folder if it does not exist and checks if the caspsule already exists.
    code = f'''
    mkdir -p {folder_name}
    if [ -d "{run_folder_name}" ]
    then
        echo "exists"
    else
        mkdir -p {run_folder_name}
        echo "ok"
    fi
    '''
    out = machine.run_code(code)
    assert len(out) == 1, str(out)
    out = out[0]

    if out == "ok":
        pass

    elif out == "exists":
        if not pargs.yes:
            c = input(f"The capsule {run_folder_name} already exists. Do you whish to continue y/n? ")
            if c == "y" or c == "Y":
                pass
            else:
                quit()
    else:
        raise Exception(f"Unexpected value {out}.")

    # Copy the local version of pargs.target to the run_folder
    machine.push(source_file_path, run_folder_name, directory=True, copy_full_dir=False, verbose=True)
    
    mode_rerun_file(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs, rerun=False)
    # Run the file and save outputs in log, save PID in the file pid.
    

def mode_rerun_file(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs, rerun=True, interpreter_args=""):
    assert pargs.name is not None, "The container_name -n must be specified."
    
    saved_settings = {}
    # Add pargs.args to the saved_settings
    if pargs.args != "":
        saved_settings["args"] = pargs.args

    if rerun:
        machine.sync_files()
        machine.push(target_file_path, target_file_path, directory=False, verbose=True)
        # Read saved settings in the run_folder
        saved_settings = settings.read_settings_from_yml(f"{run_folder_name}/.encap_config", saved_settings)
    
    if "args" in saved_settings:
        pargs.args = saved_settings["args"]
    
    pid = None

    # Initialize slurm settings from the terminal arguments
    slurm_settings = slurm.initialize_slurm_settings(pargs)

    # Are we using slurm?
    if slurm_settings is None:
        pid = run(machine, interpreter, pargs.args, run_folder_name, target_file, target_file_path, number_of_instances=pargs.i)
    else:

        # Read the slurm config file in the run folder if it exsists and it is a rerun
        if rerun:
            slurm_settings = slurm.read_slurm_settings_from_yml(f"{run_folder_name}/.slurm_config", slurm_settings)
        
        slurm_settings = slurm.read_slurm_settings_from_encapconfig(pargs, local_project_dir, slurm_settings)
        
        # Write the updated slurm config into a yml file
        with open(f"{run_folder_name}/.slurm_config", 'w') as ymlfile:
            yaml.dump(slurm_settings, ymlfile, default_flow_style=False)
        
        with open(f"{run_folder_name}/.encap_config", 'w') as ymlfile:
            yaml.dump(saved_settings, ymlfile, default_flow_style=False)
        
        # Run the SLURM job with the slurm config file
        run_slurm(machine, interpreter, pargs.target, pargs.args, run_folder_name, target_file_path, slurm_settings, name=pargs.name)

    machine.pull(run_folder_name, run_folder_name, directory=True)

    # Record active process
    record_process(pargs.vm, pargs.target, pargs.name)
    tail_pull(machine, run_folder_name, pid)
    remove_process_from_database(pargs.target, pargs.name)




if __name__ == "__main__":
    from argparse import ArgumentParser

    parser = ArgumentParser()
    parser.add_argument("mode", help="The mode of the program. Either run, rerun, tail or kill.")

    parser.add_argument("target", help="Name of the file to run.")
    parser.add_argument("-n", "--name", dest="name", help="Container name.", default=None)
    parser.add_argument("-args", "--args", dest="args", help="Arguments passed to the programm.", default="")
    parser.add_argument("-vm", "--vm_name", dest="vm", help="Name of the VM.", default=None)
    parser.add_argument("-f", "--file", dest="file", help="In case it is run on a folder this specifies the file that should be run.", default="run.py")
    parser.add_argument("-i", "--number_of_instances", dest="i", help="Number of instances to start in parallel. For each instance an enviromental variable ENCAP_INSTANCE=<instance_number> will be set. You can also pass a list or any python expression as a string. Currently not compatible with slurm.", default=1, type=eval)

    # Slurm arguments
    parser.add_argument("-sl", "--slurm", action="store_true", dest="slurm", help="Run the job on slurm. If any slurm option is used this is True by default.", default=False)
    parser.add_argument("-sl_nodes", "--slurm_nodes", dest="sl_nodes", help="Number of nodes to start in slurm. - nodes", default=None, type=int)
    parser.add_argument("-sl_ntpn", "--slurm_ntpn", dest="sl_ntpn", help="Number of tasks per node to start in slurm. - ntasks-per-node", default=None, type=int)
    parser.add_argument("-sl_time", "--slurm_time", dest="sl_time", help="Time to run the job in slurm. - time", default=None)
    parser.add_argument("-sl_partition", "--slurm_partition", dest="sl_partition", help="Partition to run the job in slurm.", default=None)
    parser.add_argument("-sl_account", "--slurm_account", dest="sl_account", help="Account to run the job in slurm.", default=None)
    parser.add_argument("-sl_cpus", "--slurm_cpus", dest="sl_cpus", help="Number of cpus to run the job in slurm. - cpus-per-task", default=None, type=int)
    parser.add_argument("-sl_i", "--slurm_instances", dest="sl_i", help="Number of seperate slurm instances to start. If you use {i} in args it will be replaced by the index number of the slurm instance. If you pass a list it will run the instances in that list. Example: -sl_i [0, 2, 3] or range(5, 20)", default=None, type=eval)
    
    # Other arguments
    parser.add_argument("-y", "--yes",
                        action="store_true", dest="yes", default=False,
                        help="All promts will be answerd with yes.")

    parser.add_argument("-d", "--debug",
                        action="store_true", dest="debug", default=False,
                        help="All commands will be printed.")

    parser.add_argument("-dr", "--dryrun",
                        action="store_true", dest="dryrun", default=False,
                        help="No command will be executed. Also implies debug.")

    pargs = parser.parse_args()

    # Read the data in
    if pargs.debug:
        settings.debug = True
    if pargs.dryrun:
        settings.dryrun = True

    t1 = time.time()
    local_project_dir = os.getcwd()
    source_file_path = pargs.target
    localmachine = LocalMachine(local_project_dir)

    if pargs.vm is not None:
        machine = get_machine(pargs.vm, local_project_dir=local_project_dir)
    else:
        machine = localmachine
    
    # Check if it will run in folder mode or file mode
    if os.path.isdir(source_file_path):
        if source_file_path[-1] == "/":
            source_file_path = source_file_path[:-1]
        folder_name = extract_folder_name(source_file_path)

        run_folder_name = f"0encap_folder/{folder_name}/{pargs.name}/"
        target_file = pargs.file
        target_file_path = run_folder_name + pargs.file # Note that pargs.file = "run.py" by default

        _, file_extension = filename_and_file_extension(target_file_path)
        interpreter = get_interpreter_from_file_extension(file_extension)

        is_file = False

    elif os.path.isfile(source_file_path):
        folder_name, file_extension = filename_and_file_extension(source_file_path)
        interpreter = get_interpreter_from_file_extension(file_extension)

        # Get the file name
        file_name = get_file_name(source_file_path)

        run_folder_name = folder_name + "/" + str(pargs.name)
        target_file = file_name
        target_file_path = run_folder_name + "/" + file_name
        is_file = True


    else:
        assert False, f"{source_file_path} is neither a directory nor a file."

    
    # See status
    # Create VM and set it up:
    #   Add GPU support

    if pargs.mode == "run":
        if is_file:
            mode_run_file(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs)
        else:
            mode_run_folder(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs)
        
    elif pargs.mode == "rerun":
        mode_rerun_file(interpreter, folder_name, run_folder_name, target_file, target_file_path, machine, pargs)
        
        
    elif pargs.mode == "tail":
        code = f"cat {run_folder_name}/pid"
        out = machine.run_code(code, verbose=True, output=True)
        print(machine.sync)
        assert len(out) == 1, out

        if out[0].isdigit():
            pid = out[0]
            print(pid)

            machine.pull(run_folder_name, run_folder_name, directory=True)

            tail_pull(machine, run_folder_name, pid)
            remove_process_from_database(pargs.target, pargs.name)

        elif  out[0][:4] == "cat:":
                machine.pull(run_folder_name, run_folder_name, directory=True)

                machine.run_code(f"cat {run_folder_name}/log", verbose=True, output=True)

    elif pargs.mode == "last":

        code = f'''
        j=1
        if [ -d "{folder_name}" ]
        then
            while [ -d "{folder_name}/$j" ]
            do
                j=$((j+1))
            done
            echo $j
        else
            if [ -f "{source_file_path}" ]
            then
                echo "NoFolder"
            else
                echo "NoFile"
            fi
        fi
        '''
        out = localmachine.run_code(code, output=True)
        print(out)
        assert len(out) == 1, str(out)
        out = out[0]

        if out == "NoFile":
            print(f"No file with name {source_file_path} exists.")

        elif out == "NoFolder":
            print("No folder has been created yet.")

        else:
            ll = int(out) - 1
            print(f"The last instance that is in the file system is {ll}.")

    elif pargs.mode == "kill":
        # checks if folder exists, if yes take the pid and kill it.
        print(run_folder_name)
        code = f"""
        if [ -f {run_folder_name}/pid ]
        then
            cat {run_folder_name}/pid
        else
            echo "NoFolder"
        fi
        """
        pid = machine.run_code(code, verbose=False, output=True)[0]
        assert not pid == "NoFolder", "The PID file was not found."
        code = f"""
        kill {pid}
        rm {run_folder_name}/pid
        """

        machine.run_code(code, verbose=True, output=True)
        print("Killed process:", pid)
        print("Currently killing is not supported.")

    elif pargs.mode == "queue":
        localmachine.push(source_file_path, folder_name + "/" + pargs.name +"/" + file_name, directory=False, verbose=True)
        localmachine.push(target_file_path, source_file_path, directory=False, verbose=True)

        if pargs.vm is None:
            assert False
        code = f"""
        cd ~/.encap
        mkdir -p queue
        cd queue
        echo "encap rerun {pargs.target} -n {pargs.name} -vm {pargs.vm} -args '{pargs.args}'" &>> {pargs.vm}

        if [[ -a {pargs.vm}_pending ]]
        then
            echo "encap rerun {pargs.target} -n {pargs.name} -vm {pargs.vm} -y -args '{pargs.args}'" &>> {pargs.vm}_pending
        fi
        """
        localmachine.run_code(code)

    elif pargs.mode == "runqueue":
        assert pargs.name is not None, "The container_name -n must be specified."

        if pargs.vm is None:
            assert False

        task_f = f"~/.encap/queue/{pargs.vm}"
        code = f"""
        cp {task_f} {task_f}_pending

        while [[ -s {task_f}_pending ]]
        do
            echo `head -n 1 {task_f}_pending` > {task_f}_current
            cat {task_f}_current
            bash {task_f}_current
            sed -i '1d' {task_f}_pending

        done
        rm {task_f}_pending
        rm {task_f}_current
        """
        machine.run_code(code, output=True, verbose=True)

    elif pargs.mode == "pull":
        assert pargs.name is not None, "The container_name -n must be specified."
        machine.pull(run_folder_name, run_folder_name, directory=True, verbose=True)

    elif pargs.mode == "push":
        assert pargs.name is not None, "The container_name -n must be specified."
        machine.push(run_folder_name, run_folder_name, directory=True, verbose=True)

    elif pargs.mode == "loadsave":
        assert pargs.name is not None, "The container_name -n must be specified."
        localmachine.push(source_file_path, folder_name + "/save/" + file_name, directory=False, verbose=True)
        localmachine.push(target_file_path, source_file_path, directory=False, verbose=True)

    elif pargs.mode == "save":
        assert pargs.name is not None, "The container_name -n must be specified."
        localmachine.push(source_file_path, folder_name + "/" + pargs.name +"/" + file_name, directory=False, verbose=True)
        localmachine.push(target_file_path, source_file_path, directory=False, verbose=True)

    elif pargs.mode == "load":
        assert pargs.name is not None, "The container_name -n must be specified."
        localmachine.push(target_file_path, source_file_path, directory=False, verbose=True)

    elif pargs.mode == "reload":
        assert pargs.name is not None, "The container_name -n must be specified."
        localmachine.push(folder_name + "/save/" + file_name, source_file_path, directory=False, verbose=True)

    elif pargs.mode == "pkill":
        machine.run_code(f"pkill -f '{pargs.target}' -u {machine.username}", output=True, verbose=True)

    else:
        raise ValueError(f"The mode '{pargs.mode}' is not available.")
